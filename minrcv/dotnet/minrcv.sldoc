<html>
<head>
=semlit,include,../../style/head.sldoc=
<title>minrcv: Minimal UM subscriber in C#/.NET</title>
</head>
<body>
=semlit,include,../intro.sldoc=

<p>There is one program source file:</p>
<ul>
<li><b><tt>=semlit,srcfile,minrcv_cs.slsrc,minrcv.cs=</tt></b>
- (right-click and save as "minrcv.cs") Example code.</li>
</ul>

<h2><tt>minrcv.cs</tt></h2>

<h3>Initialization</h3>

<p>The first phase of any UM program is initialization, where UM objects are
created. The first object to be created is a UM context object:</p>
=semlit,insert,ctx_create=

<p>A context can be thought of as an "instance" of UM. It contains a worker
thread which maintains internal state and reacts to socket events. Most UM
applications create a single context instance which manages the publishing
and receiving of messages over many topics, although there are less-common
use cases which call for multiple context instances within a single process
(see TODO).</p>

<p>Also note the use of <tt>EX_LBM_CHK(err)</tt>. This is a simple error
handling macro, described more-fully later on.</p>

<p>The next object that needs to be created is a "receiver" object. Creation
of a receiver object is a two-step procedure: first obtain a "topic" object,
specifying the topic name and any desired receiver attributes, and then create
the "receiver" object, which is the object used subsequently to receive messages.</p>
=semlit,insert,src_create=

<p>The first thing to note is the use curly braces to create a block. This
is not necessary, but is done in this example to emphasize that the
<tt>topic</tt> variable is only used as a bridge between the following
two function calls. The <tt>lbm_rcv_topic_lookup()</tt> function allocates
a topic object internally inside the context and returns a handle to that
object. However, there is only one thing that can be done with this topic
object: use it to create a receiver object. Once that receiver object is created,
the application no longer needs to retain the topic object. It is unique among
UM objects in that the application does not need to manage or clean up topic
objects explicitly -- e.g. there is no <tt>lbm_src_topic_delete()</tt> function.</p>

<p>Next note the third parameter passed to <tt>lbm_rcv_create()</tt>:
the function pointer <tt>app_rcv_callback</tt>. This funciton is
explained in detail a bit later on. For now, understand that
the UM library will call that function for each message received.</p>

<p>Note that it would be unusual for a real application to create a single
topic for all its communication needs. Most real-world applications would
create several receivers, all within the same context. Just be aware that each
one requires the same topic_lookup/rcv_create pairing.<p>

<h3>Receiving</h3>

<p>Now that initialization is complete, it is time to receive a message.
However, this is not done in the "main" thread. For this example, the
"main" thread is not needed for anything after initialization; it is
just coded as an infinite loop of sleeps:</p>
=semlit,insert,main_sleep=

<p>Actual reception of messages is done by the context thread, which was
started when the context object was created. When the context receives a
message, it calls the application callback specified in the receiver
creation: <tt>app_rcv_callback()</tt>:</p>
=semlit,insert,app_rcv_cb=

<p>Note that the function needs to be declared as shown, in conformance with
the <tt>lbm_rcv_cb_proc</tt> function type defined in <tt>lbm.h</tt>:</p>
<pre>
  typedef int(*) lbm_rcv_cb_proc(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)
</pre>

<p>The first thing to understand is that this function is called when UM
has events to deliver, and received messages are only one kind of event.
Therefore, the first thing the receiver callback must do is check the
event type:</p>
=semlit,insert,rcv_switch=

<p>For this minimal subscriber, the only event type of interest is
<tt>LBM_MSG_DATA</tt>, which indicates that a message has been received
and is being delivered to the application. The <tt>msg</tt> parameter
points at an <tt>lbm_msg_t_stct</tt> structure which contains various
metadata about the message, in addition to a pointer to the message
itself, <tt>msg->data</tt>. UM simply interprets the message as an
array of <tt>char</tt>s; the number of <tt>char</tt>s indicated in
<tt>msg->len</tt>.</p>

<p>For this simple example, it is assumed that the message contents
is an ascii string. The <tt>printf</tt> format
string "<tt>%.*s</tt>" is used in case the sender does not include
a null terminator in the string; the "<tt>*</tt>" tells printf to
take the "precision" (maximum number of characters for a string)
from the parameter list, in this case <tt>msg->len</tt>.</p>

<p>Finally, almost all UM application callback functions require
that the application return <tt>0</tt>. It is not appropriate to
return a non-zero value, even if the callback detected an error.</p>

<p>Be aware that the application callback is executed by the
context thread. The context thread is sensitive to delays,
especially if UDP-based protocols are delivering data
(i.e. LBT-RM or LBT-RU). The receiver callback should
never block for significant periods of time; even a few
hundred microseconds can result in packet loss during
traffic bursts.</p>

<p>If some messages require time-consuming processing, it
is recommended for the application to queue the message
for processing by an application thread, allowing the
receiver callback to return immediately. Alternatively,
the UM "event queue" can be used; see TODO.</p>

<h3>Cleanup</h3>

<p>In this example program, no cleanup is needed since the "main" thread
executes an infinite loop, requiring the user to abort the program
manually. However, for illustration purposes, cleanup code is included
after the infinite loop.</p>

<p>When deleting UM objects, order of deletion is important:</p>
=semlit,insert,delobj=

<p>In general, timers should be cancelled first. Then source and receiver
objects should be deleted, then context objects, and lastly event queues.
These object deletions can become somewhat complex if event queues are
used; see TODO for more explanation.</p>

=semlit,include,../../main.sldoc=

=semlit,include,../advanced.sldoc=
</body>
</html>
